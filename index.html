<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>本地全格式转换工具</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .lib-dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; margin-right: 6px; }
    .dot-idle { background-color: #d1d5db; }
    .dot-loading { background-color: #f59e0b; animation: pulse 1.5s infinite; }
    .dot-success { background-color: #10b981; }
    .dot-error { background-color: #ef4444; }
    @keyframes pulse { 0%, 100% { opacity: 0.6; } 50% { opacity: 1; } }
    .hidden-tab { display: none; }
  </style>
</head>
<body class="bg-gray-50 min-h-screen text-gray-800">

  <!-- 顶部 -->
  <header class="bg-white shadow-sm border-b">
    <div class="max-w-5xl mx-auto px-4 py-5">
      <h1 class="text-2xl font-bold text-gray-900">本地全格式转换工具</h1>
      <p class="text-sm text-gray-500 mt-1">所有文件在本地浏览器处理，无需上传服务器 | 推荐 Chrome/Edge</p>
    </div>
  </header>

  <!-- 主内容 -->
  <main class="max-w-5xl mx-auto px-4 py-8">
    
    <!-- 状态提示区 -->
    <div id="statusBar" class="mb-6 p-3 bg-white rounded-lg shadow-sm border border-gray-200 flex justify-between items-center text-sm">
      <div id="statusText">就绪</div>
      <div id="miniLibStatus" class="flex gap-4"></div>
    </div>

    <!-- Tab 导航 -->
    <nav class="flex border-b border-gray-200 mb-6" id="mainTabs">
      <button class="tab-btn active px-4 py-2 font-medium border-b-2 border-blue-600 text-blue-600" data-tab="image">图片</button>
      <button class="tab-btn px-4 py-2 font-medium border-b-2 border-transparent text-gray-500 hover:text-gray-700" data-tab="video">视频</button>
      <button class="tab-btn px-4 py-2 font-medium border-b-2 border-transparent text-gray-500 hover:text-gray-700" data-tab="audio">音频</button>
      <button class="tab-btn px-4 py-2 font-medium border-b-2 border-transparent text-gray-500 hover:text-gray-700" data-tab="doc">文档</button>
      <button class="tab-btn px-4 py-2 font-medium border-b-2 border-transparent text-gray-500 hover:text-gray-700" data-tab="pdf">PDF</button>
    </nav>

    <!-- 图片转换 -->
    <section id="panel-image" class="tab-panel bg-white p-6 rounded-lg shadow-sm border border-gray-200">
      <h2 class="text-lg font-semibold mb-4">图片格式互转</h2>
      <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
        <div class="md:col-span-3">
          <label class="block text-sm font-medium text-gray-700 mb-1">选择文件</label>
          <input type="file" id="img-input" accept="image/*" class="w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded file:border-0 file:bg-blue-50 file:text-blue-700">
        </div>
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-1">目标格式</label>
          <select id="img-format" class="w-full border-gray-300 rounded-md shadow-sm focus:border-blue-500 focus:ring-blue-500">
            <option value="webp">WebP</option>
            <option value="jpeg">JPG</option>
            <option value="png">PNG</option>
          </select>
        </div>
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-1">质量 (0.1-1.0)</label>
          <input type="number" id="img-quality" value="0.9" min="0.1" max="1" step="0.1" class="w-full border-gray-300 rounded-md shadow-sm focus:border-blue-500 focus:ring-blue-500">
        </div>
      </div>
      <button id="img-btn" class="w-full bg-blue-600 text-white py-2 rounded hover:bg-blue-700 transition">开始转换</button>
      <div id="img-down" class="mt-4 hidden">
        <a id="img-link" class="text-green-600 font-medium hover:underline" download>点击下载文件</a>
      </div>
    </section>

    <!-- 视频转换 -->
    <section id="panel-video" class="tab-panel hidden-tab bg-white p-6 rounded-lg shadow-sm border border-gray-200">
      <h2 class="text-lg font-semibold mb-4">视频格式转换 (FFmpeg)</h2>
      <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
        <div class="md:col-span-2">
          <label class="block text-sm font-medium text-gray-700 mb-1">选择文件</label>
          <input type="file" id="vid-input" accept="video/*" class="w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded file:border-0 file:bg-blue-50 file:text-blue-700">
        </div>
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-1">目标格式</label>
          <select id="vid-format" class="w-full border-gray-300 rounded-md shadow-sm focus:border-blue-500 focus:ring-blue-500">
            <option value="mp4">MP4 (H.264)</option>
            <option value="webm">WebM</option>
            <option value="mp3">提取MP3</option>
            <option value="gif">GIF动图</option>
          </select>
        </div>
      </div>
      <p class="text-xs text-gray-500 mb-4">注：首次使用需加载约25MB的引擎文件，请耐心等待。</p>
      <button id="vid-btn" class="w-full bg-blue-600 text-white py-2 rounded hover:bg-blue-700 transition">开始转换</button>
      <div id="vid-down" class="mt-4 hidden">
        <a id="vid-link" class="text-green-600 font-medium hover:underline" download>点击下载文件</a>
      </div>
    </section>

    <!-- 音频转换 -->
    <section id="panel-audio" class="tab-panel hidden-tab bg-white p-6 rounded-lg shadow-sm border border-gray-200">
      <h2 class="text-lg font-semibold mb-4">音频格式转换</h2>
      <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
        <div class="md:col-span-2">
          <label class="block text-sm font-medium text-gray-700 mb-1">选择文件</label>
          <input type="file" id="aud-input" accept="audio/*" class="w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded file:border-0 file:bg-blue-50 file:text-blue-700">
        </div>
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-1">目标格式</label>
          <select id="aud-format" class="w-full border-gray-300 rounded-md shadow-sm focus:border-blue-500 focus:ring-blue-500">
            <option value="mp3">MP3</option>
            <option value="wav">WAV</option>
            <option value="flac">FLAC</option>
            <option value="m4a">M4A</option>
          </select>
        </div>
      </div>
      <button id="aud-btn" class="w-full bg-blue-600 text-white py-2 rounded hover:bg-blue-700 transition">开始转换</button>
      <div id="aud-down" class="mt-4 hidden">
        <a id="aud-link" class="text-green-600 font-medium hover:underline" download>点击下载文件</a>
      </div>
    </section>

    <!-- 文档转换 -->
    <section id="panel-doc" class="tab-panel hidden-tab bg-white p-6 rounded-lg shadow-sm border border-gray-200">
      <h2 class="text-lg font-semibold mb-4">Office/Markdown 转换</h2>
      <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
        <div class="md:col-span-2">
          <label class="block text-sm font-medium text-gray-700 mb-1">选择文件 (.xlsx, .docx, .md)</label>
          <input type="file" id="doc-input" accept=".xlsx,.docx,.md,.txt" class="w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded file:border-0 file:bg-blue-50 file:text-blue-700">
        </div>
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-1">目标格式</label>
          <select id="doc-format" class="w-full border-gray-300 rounded-md shadow-sm focus:border-blue-500 focus:ring-blue-500">
            <option value="pdf">PDF</option>
            <option value="html">HTML</option>
            <option value="txt">纯文本</option>
            <option value="json">JSON (Excel)</option>
          </select>
        </div>
      </div>
      <button id="doc-btn" class="w-full bg-blue-600 text-white py-2 rounded hover:bg-blue-700 transition">开始转换</button>
      <div id="doc-down" class="mt-4 hidden">
        <a id="doc-link" class="text-green-600 font-medium hover:underline" download>点击下载文件</a>
      </div>
    </section>

    <!-- PDF处理 -->
    <section id="panel-pdf" class="tab-panel hidden-tab bg-white p-6 rounded-lg shadow-sm border border-gray-200">
      <h2 class="text-lg font-semibold mb-4">PDF 工具箱</h2>
      <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
        <div class="md:col-span-2">
          <label class="block text-sm font-medium text-gray-700 mb-1">选择文件 (PDF 或 图片)</label>
          <input type="file" id="pdf-input" multiple accept=".pdf,image/*" class="w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded file:border-0 file:bg-blue-50 file:text-blue-700">
        </div>
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-1">操作</label>
          <select id="pdf-action" class="w-full border-gray-300 rounded-md shadow-sm focus:border-blue-500 focus:ring-blue-500">
            <option value="to-img">PDF 转图片 (ZIP)</option>
            <option value="to-txt">PDF 提取文本</option>
            <option value="merge">图片合并 PDF</option>
          </select>
        </div>
      </div>
      <button id="pdf-btn" class="w-full bg-blue-600 text-white py-2 rounded hover:bg-blue-700 transition">开始处理</button>
      <div id="pdf-down" class="mt-4 hidden">
        <a id="pdf-link" class="text-green-600 font-medium hover:underline" download>点击下载文件</a>
      </div>
    </section>

  </main>

  <script>
    (function() {
      // ================= 配置与状态 =================
      const LIBS = {
        xlsx: {
          var: 'XLSX',
          urls: ['https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js']
        },
        mammoth: {
          var: 'mammoth',
          urls: ['https://cdn.jsdelivr.net/npm/mammoth@1.6.0/mammoth.browser.min.js']
        },
        jspdf: {
          var: 'jspdf',
          urls: ['https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js']
        },
        pdfjs: {
          var: 'pdfjsLib',
          urls: ['https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.0.379/pdf.min.js'],
          init: () => { if(window.pdfjsLib) window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.0.379/pdf.worker.min.js'; }
        },
        jszip: {
          var: 'JSZip',
          urls: ['https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js']
        },
        ffmpeg: {
          var: 'FFmpeg',
          urls: ['https://unpkg.com/@ffmpeg/ffmpeg@0.12.10/dist/ffmpeg.min.js'],
          core: 'https://unpkg.com/@ffmpeg/core@0.12.10/dist/ffmpeg-core.js'
        }
      };

      const state = {
        loaded: {},
        ffmpeg: null,
        ffmpegReady: false,
        busy: false,
        activeBlob: null
      };

      // ================= 工具函数 =================
      const $ = (id) => document.getElementById(id);
      const setStatus = (msg) => $('statusText').textContent = msg;
      
      const clearBlob = () => {
        if (state.activeBlob) {
          URL.revokeObjectURL(state.activeBlob);
          state.activeBlob = null;
        }
        // 隐藏所有下载链接
        ['img-down','vid-down','aud-down','doc-down','pdf-down'].forEach(id => $(id).classList.add('hidden'));
      };

      const triggerDownload = (linkEl, blob, filename) => {
        clearBlob();
        const url = URL.createObjectURL(blob);
        state.activeBlob = url;
        linkEl.href = url;
        linkEl.download = filename;
        linkEl.parentElement.classList.remove('hidden');
      };

      // 动态加载脚本
      const loadScript = (src) => {
        return new Promise((res, rej) => {
          const s = document.createElement('script');
          s.src = src;
          s.onload = () => res();
          s.onerror = () => rej(new Error(`Failed to load ${src}`));
          document.head.appendChild(s);
        });
      };

      // 确保库加载
      const ensureLib = async (name) => {
        if (state.loaded[name]) return true;
        const lib = LIBS[name];
        if (!lib) return false;

        setStatus(`正在加载依赖库: ${name}...`);
        for (const url of lib.urls) {
          try {
            await loadScript(url);
            if (window[lib.var]) {
              if (lib.init) lib.init();
              state.loaded[name] = true;
              updateMiniStatus();
              return true;
            }
          } catch (e) { console.warn(e); }
        }
        setStatus(`错误: 无法加载库 ${name}`);
        return false;
      };

      // 初始化 FFmpeg
      const initFFmpeg = async () => {
        if (state.ffmpegReady) return true;
        if (!(await ensureLib('ffmpeg'))) return false;
        
        setStatus("正在初始化 FFmpeg (约30MB)...");
        try {
          const { createFFmpeg, fetchFile } = FFmpeg;
          state.ffmpeg = createFFmpeg({ log: false, corePath: LIBS.ffmpeg.core });
          await state.ffmpeg.load();
          state.ffmpegReady = true;
          state.fetchFile = fetchFile;
          updateMiniStatus();
          return true;
        } catch (e) {
          setStatus("FFmpeg 初始化失败");
          return false;
        }
      };

      // 更新右上角小状态
      const updateMiniStatus = () => {
        const container = $('miniLibStatus');
        container.innerHTML = '';
        // 只显示几个关键库
        const checks = [
          { id: 'xlsx', label: 'Excel' },
          { id: 'ffmpeg', label: 'FFmpeg', ready: () => state.ffmpegReady }
        ];
        
        checks.forEach(c => {
          const div = document.createElement('div');
          div.className = 'flex items-center';
          const dot = document.createElement('span');
          
          let isReady = state.loaded[c.id];
          if (c.ready) isReady = c.ready();

          dot.className = `lib-dot ${isReady ? 'dot-success' : 'dot-idle'}`;
          div.appendChild(dot);
          div.appendChild(document.createTextNode(c.label));
          container.appendChild(div);
        });
      };

      // ================= Tab 切换 =================
      document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          // UI 更新
          document.querySelectorAll('.tab-btn').forEach(b => {
            b.classList.remove('border-blue-600', 'text-blue-600');
            b.classList.add('border-transparent', 'text-gray-500');
          });
          btn.classList.add('border-blue-600', 'text-blue-600');
          btn.classList.remove('border-transparent', 'text-gray-500');

          // 面板切换
          const tab = btn.dataset.tab;
          document.querySelectorAll('.tab-panel').forEach(p => p.classList.add('hidden-tab'));
          $(`panel-${tab}`).classList.remove('hidden-tab');
          clearBlob();
          setStatus("就绪");
        });
      });

      // ================= 功能实现 =================

      // 1. 图片转换
      $('img-btn').addEventListener('click', async () => {
        if (state.busy) return;
        const file = $('img-input').files[0];
        if (!file) return setStatus("请先选择图片");
        
        state.busy = true;
        setStatus("处理中...");
        clearBlob();

        try {
          const img = new Image();
          img.src = URL.createObjectURL(file);
          await new Promise((res, rej) => { img.onload = res; img.onerror = rej; });

          const canvas = document.createElement('canvas');
          canvas.width = img.width;
          canvas.height = img.height;
          canvas.getContext('2d').drawImage(img, 0, 0);
          URL.revokeObjectURL(img.src);

          const fmt = $('img-format').value;
          const quality = parseFloat($('img-quality').value);
          const blob = await new Promise(res => canvas.toBlob(res, `image/${fmt}`, quality));
          
          const newName = file.name.replace(/\.[^\.]+$/, `.${fmt}`);
          triggerDownload($('img-link'), blob, newName);
          setStatus("转换完成");
        } catch (e) {
          setStatus("转换失败: " + e.message);
        } finally {
          state.busy = false;
        }
      });

      // 通用 FFmpeg 处理
      const runFFmpeg = async (file, ext, args, outName, mime) => {
        if (!(await initFFmpeg())) return;
        const { ffmpeg, fetchFile } = state;
        
        const inName = `input.${ext}`;
        ffmpeg.FS('writeFile', inName, await fetchFile(file));
        await ffmpeg.run(...args);
        
        const data = ffmpeg.FS('readFile', outName);
        // 清理
        try { ffmpeg.FS('unlink', inName); ffmpeg.FS('unlink', outName); } catch(e){}
        return new Blob([data.buffer], { type: mime });
      };

      // 2. 视频转换
      $('vid-btn').addEventListener('click', async () => {
        if (state.busy) return;
        const file = $('vid-input').files[0];
        if (!file) return setStatus("请先选择视频");
        
        state.busy = true;
        setStatus("准备中...");
        clearBlob();

        try {
          const fmt = $('vid-format').value;
          const ext = file.name.split('.').pop();
          const outFile = 'output.' + (fmt === 'mp3' ? 'mp3' : fmt);
          const mime = fmt === 'mp3' ? 'audio/mpeg' : `video/${fmt}`;
          
          let args = ['-i', 'input.' + ext];
          if (fmt === 'gif') {
             args = args.concat(['-t', '10', '-vf', 'fps=10,scale=480:-1', '-f', 'gif']); // 默认只转10秒防止太大
          } else if (fmt === 'mp3') {
             args = args.concat(['-vn', '-acodec', 'libmp3lame', '-ab', '192k']);
          } else if (fmt === 'webm') {
             args = args.concat(['-c:v', 'libvpx', '-b:v', '1M', '-c:a', 'libvorbis']);
          }
          args.push(outFile);

          setStatus("正在转换 (这可能需要几分钟)...");
          const blob = await runFFmpeg(file, ext, args, outFile, mime);
          
          triggerDownload($('vid-link'), blob, file.name.replace(/\.[^\.]+$/, `.${fmt}`));
          setStatus("转换完成");
        } catch (e) {
          setStatus("失败: " + e.message);
        } finally {
          state.busy = false;
        }
      });

      // 3. 音频转换
      $('aud-btn').addEventListener('click', async () => {
        if (state.busy) return;
        const file = $('aud-input').files[0];
        if (!file) return setStatus("请先选择音频");
        
        state.busy = true;
        setStatus("准备中...");
        clearBlob();

        try {
          const fmt = $('aud-format').value;
          const ext = file.name.split('.').pop();
          const outFile = 'output.' + fmt;
          const mimeMap = { mp3: 'audio/mpeg', wav: 'audio/wav', flac: 'audio/flac', m4a: 'audio/mp4' };
          
          let args = ['-i', 'input.' + ext];
          if (fmt === 'mp3') args.push('-acodec', 'libmp3lame', '-ab', '320k');
          else if (fmt === 'wav') args.push('-acodec', 'pcm_s16le');
          else if (fmt === 'flac') args.push('-acodec', 'flac');
          else if (fmt === 'm4a') args.push('-acodec', 'aac', '-ab', '320k', '-f', 'mp4');
          args.push(outFile);

          setStatus("正在转换...");
          const blob = await runFFmpeg(file, ext, args, outFile, mimeMap[fmt] || 'audio/octet-stream');
          
          triggerDownload($('aud-link'), blob, file.name.replace(/\.[^\.]+$/, `.${fmt}`));
          setStatus("转换完成");
        } catch (e) {
          setStatus("失败: " + e.message);
        } finally {
          state.busy = false;
        }
      });

      // 简易 HTML 转 PDF (图片方式，保证样式)
      const htmlToPdf = async (htmlStr) => {
        if (!(await ensureLib('jspdf'))) return;
        const { jsPDF } = jspdf;
        
        // 临时渲染
        const container = document.createElement('div');
        container.innerHTML = htmlStr;
        container.style.position = 'absolute';
        container.style.left = '-10000px';
        container.style.top = '0';
        container.style.background = 'white';
        container.style.padding = '20px';
        document.body.appendChild(container);

        // 这里为了轻量化，使用简单的分页逻辑，如果是复杂文档建议用 html2canvas，但为了减少依赖，这里假设是纯文本/表格
        // 为了稳定性，我们还是用最基础的文本方式处理Docx，Excel用表格绘制
        // 上面的渲染只是为了获取文本，这里简化处理：
        const text = container.innerText;
        document.body.removeChild(container);

        const pdf = new jsPDF();
        const lines = pdf.splitTextToSize(text, 180);
        pdf.text(lines, 14, 20);
        return pdf.output('blob');
      };

      // 4. 文档转换
      $('doc-btn').addEventListener('click', async () => {
        if (state.busy) return;
        const file = $('doc-input').files[0];
        if (!file) return setStatus("请先选择文档");
        
        state.busy = true;
        setStatus("处理中...");
        clearBlob();

        const ext = file.name.split('.').pop().toLowerCase();
        const target = $('doc-format').value;
        let blob = null;
        let filename = file.name.replace(/\.[^\.]+$/, `.${target}`);

        try {
          const buf = await file.arrayBuffer();

          if (ext === 'xlsx') {
            if (!(await ensureLib('xlsx'))) return;
            const wb = XLSX.read(buf);
            const ws = wb.Sheets[wb.SheetNames[0]];
            
            if (target === 'json') {
              const json = XLSX.utils.sheet_to_json(ws);
              blob = new Blob([JSON.stringify(json, null, 2)], {type: 'application/json'});
            } else if (target === 'pdf') {
               if (!(await ensureLib('jspdf'))) return;
               const csv = XLSX.utils.sheet_to_csv(ws);
               // 简单CSV转PDF
               const { jsPDF } = jspdf;
               const pdf = new jsPDF();
               pdf.setFontSize(10);
               const lines = pdf.splitTextToSize(csv, 280);
               pdf.text(lines, 10, 10);
               blob = pdf.output('blob');
            } else {
               const csv = XLSX.utils.sheet_to_csv(ws);
               blob = new Blob(['\ufeff' + csv], {type: 'text/csv'});
               filename = filename.replace('.pdf', '.csv').replace('.html', '.csv');
            }
          } 
          else if (ext === 'docx') {
            if (!(await ensureLib('mammoth'))) return;
            const result = await mammoth.convertToHtml({ arrayBuffer: buf });
            const html = result.value;
            
            if (target === 'html') {
              blob = new Blob([html], {type: 'text/html'});
            } else if (target === 'pdf') {
               blob = await htmlToPdf(html);
            } else {
               const d = document.createElement('div'); d.innerHTML = html;
               blob = new Blob([d.innerText], {type: 'text/plain'});
            }
          }
          else if (ext === 'md' || ext === 'txt') {
             const text = await file.text();
             if (target === 'pdf') {
                blob = await htmlToPdf(`<pre>${text}</pre>`);
             } else {
                blob = new Blob([text], {type: 'text/plain'});
             }
          }

          if (blob) {
            triggerDownload($('doc-link'), blob, filename);
            setStatus("转换完成");
          } else {
            setStatus("不支持的转换格式");
          }
        } catch (e) {
          setStatus("失败: " + e.message);
        } finally {
          state.busy = false;
        }
      });

      // 5. PDF 处理
      $('pdf-btn').addEventListener('click', async () => {
        if (state.busy) return;
        const files = Array.from($('pdf-input').files);
        if (files.length === 0) return setStatus("请先选择文件");
        
        state.busy = true;
        setStatus("处理中...");
        clearBlob();

        const action = $('pdf-action').value;
        let blob = null;
        let filename = "output";

        try {
          if (action === 'merge') {
            if (!(await ensureLib('jspdf'))) return;
            const { jsPDF } = jspdf;
            const pdf = new jsPDF();
            const imgs = files.filter(f => f.type.startsWith('image'));
            
            for(let i=0; i<imgs.length; i++) {
              setStatus(`添加图片 ${i+1}/${imgs.length}`);
              const url = URL.createObjectURL(imgs[i]);
              const img = new Image();
              img.src = url;
              await new Promise(r => img.onload = r);
              
              if(i>0) pdf.addPage();
              const pw = pdf.internal.pageSize.getWidth();
              const ph = pdf.internal.pageSize.getHeight();
              const ratio = Math.min(pw/img.width, ph/img.height) * 0.9;
              const w = img.width * ratio;
              const h = img.height * ratio;
              pdf.addImage(img, 'PNG', (pw-w)/2, (ph-h)/2, w, h);
              URL.revokeObjectURL(url);
            }
            blob = pdf.output('blob');
            filename = "合并.pdf";
          } 
          else {
            const pdfFile = files.find(f => f.type === 'application/pdf');
            if (!pdfFile) throw new Error("请选择PDF文件");
            
            if (!(await ensureLib('pdfjs'))) return;
            if (action === 'to-img') await ensureLib('jszip');

            const buf = await pdfFile.arrayBuffer();
            const pdf = await pdfjsLib.getDocument(buf).promise;

            if (action === 'to-txt') {
              let text = "";
              for(let i=1; i<=pdf.numPages; i++) {
                setStatus(`提取文本 ${i}/${pdf.numPages}`);
                const page = await pdf.getPage(i);
                const content = await page.getTextContent();
                text += `--- Page ${i} ---\n`;
                text += content.items.map(it => it.str).join(' ') + "\n";
              }
              blob = new Blob([text], {type: 'text/plain'});
              filename = pdfFile.name.replace('.pdf', '.txt');
            } 
            else if (action === 'to-img') {
              const zip = new JSZip();
              const maxPages = Math.min(pdf.numPages, 50); // 限制50页
              for(let i=1; i<=maxPages; i++) {
                setStatus(`渲染图片 ${i}/${maxPages}`);
                const page = await pdf.getPage(i);
                const scale = 2;
                const viewport = page.getViewport({scale});
                const canvas = document.createElement('canvas');
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                await page.render({canvasContext: canvas.getContext('2d'), viewport}).promise;
                
                const imgBlob = await new Promise(r => canvas.toBlob(r, 'image/png'));
                zip.file(`page_${i}.png`, imgBlob);
              }
              blob = await zip.generateAsync({type: 'blob'});
              filename = pdfFile.name.replace('.pdf', '_images.zip');
            }
          }

          if (blob) {
            triggerDownload($('pdf-link'), blob, filename);
            setStatus("处理完成");
          }
        } catch (e) {
          setStatus("失败: " + e.message);
        } finally {
          state.busy = false;
        }
      });

      // 初始化
      updateMiniStatus();
      setStatus("就绪");

    })();
  </script>
</body>
</html>